module NormalDistribution (NormalDist, make, toGen, toGen2) where

import Result exposing (Result)

import Random exposing (Generator, Seed, customGenerator, generate)
import Random.Extra as Random
import TupleUtil exposing (dimap)

type alias NormalDist = { mean : Float, variance : Float }

make : Float -> Float -> NormalDist
make mean stddev = { mean=mean, variance=stddev^2 }

fromSTS : NormalDist -> Float -> Float
fromSTS {mean, variance} sts = mean + sts * sqrt variance

-- generates a value from the normal distribution, while most convenient,
-- this drops an extra value produced by the underlying Box-Muller
-- implementation
toGen : NormalDist -> Generator Float
toGen dist = Random.map (fromSTS dist << fst) boxMuller

-- efficiently produces two floats from the given normal distributions, taking
-- advantage of the second value generated by the Box-Muller implementation
toGen2 : NormalDist -> NormalDist -> Generator (Float, Float)
toGen2 a b = Random.map (dimap (fromSTS a) (fromSTS b)) boxMuller

-- translated from C at http://www.design.caltech.edu/erik/Misc/Gaussian.html
boxMuller : Generator (Float, Float)
boxMuller = customGenerator <| \seed ->
    let iteratee : Seed -> Result Seed ((Float, Float, Float), Seed)
        iteratee seed =
            let xGen = Random.map (\n -> 2.0 * n - 1) <| Random.float 0 1
                ((x1, x2), seed') = generate (Random.pair xGen xGen) seed
                w = x1 ^ 2 + x2 ^ 2
            in if w >= 1.0 then Err seed' else Ok ((w, x1, x2), seed')
        ((w, x1, x2), seed') = until iteratee seed
        w' = sqrt (-2.0 * (logBase e w) / w)
    in ((x1 * w', x2 * w'), seed')

-- Utility Functions ----------------------------------------------------------
until : (a -> Result a b) -> a -> b
until f = either (until f) identity << f

either : (a -> c) -> (b -> c) -> Result a b -> c
either f g e = case e of
    Err a -> f a
    Ok  b -> g b
